#!/usr/bin/env python3

from __future__ import print_function

import argparse
import json
import logging
import os
import signal
import sqlite3
import ssl
import subprocess
import sys
from time import sleep

from flask import Flask, request, jsonify, make_response, g
# Empire imports
from flask_smorest import Api

from lib.api.agents.endpoints import agen_blp
from lib.api.config import FlaskConfig
from lib.api.listeners.endpoints import lis_blp
from lib.api.meta.endpoints import meta_blp
from lib.api.modules.endpoints import modu_blp
from lib.api.stagers.endpoints import sta_blp
from lib.api.users.endpoints import user_blp
from lib.common import empire, helpers
from lib.common.users import Users
from lib.database.base import Session

if sys.version[0] == '2':
    print(helpers.color("[!] Please use Python 3"))
    sys.exit()

global serverExitCommand
serverExitCommand = 'restart'


#####################################################
#
# Database interaction methods for the RESTful API
#
#####################################################


def database_check_docker():
    """
    Check for docker and setup database if nessary.
    """
    if os.path.exists('/.dockerenv'):
        if not os.path.exists('data/empire.db'):
            print('[*] Fresh start in docker, running reset.sh for you')
            subprocess.call(['./setup/reset.sh'])


def database_connect():
    """
    Connect with the backend ./empire.db sqlite database and return the
    connection object.
    """
    try:
        # set the database connectiont to autocommit w/ isolation level
        conn = sqlite3.connect('./data/empire.db', check_same_thread=False)
        conn.text_factory = str
        conn.isolation_level = None
        return conn

    except Exception:
        print(helpers.color("[!] Could not connect to database"))
        print(helpers.color("[!] Please run setup_database.py"))
        sys.exit()


def execute_db_query(conn, query, args=None):
    """
    Execute the supplied query on the provided db conn object
    with optional args for a paramaterized query.
    """
    cur = conn.cursor()
    if args:
        cur.execute(query, args)
    else:
        cur.execute(query)
    results = cur.fetchall()
    cur.close()
    return results


####################################################################
#
# The Empire RESTful API.
#
# Adapted from http://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask
#   example code at https://gist.github.com/miguelgrinberg/5614326
#
#    Verb     URI                                                   Action
#    ----     ---                                                   ------
#    GET      http://localhost:1337/api/creds                       return stored credentials
#    POST     http://localhost:1337/api/creds                       add creds to the database
#
#    GET      http://localhost:1337/api/reporting                   return all logged events
#    GET      http://localhost:1337/api/reporting/agent/X           return all logged events for the given agent name X
#    GET      http://localhost:1337/api/reporting/type/Y            return all logged events of type Y (checkin, task, result, rename)
#    GET      http://localhost:1337/api/reporting/msg/Z             return all logged events matching message Z, wildcards accepted
#
#
#    GET      http://localhost:1337/api/admin/restart               restart the RESTful API
#    GET      http://localhost:1337/api/admin/shutdown              shutdown the RESTful API
#
####################################################################

def start_restful_api(empireMenu, suppress=False, username=None, password=None, port=1337, insecure=False):
    """
    Kick off the RESTful API with the given parameters.

    empireMenu  -   Main empire menu object
    suppress    -   suppress most console output
    username    -   optional username to use for the API, otherwise pulls from the empire.db config
    password    -   optional password to use for the API, otherwise pulls from the empire.db config
    port        -   port to start the API on, defaults to 1337 ;)
    """
    app = Flask(__name__)
    app.config.from_object(FlaskConfig)

    api = Api(app)
    api.register_blueprint(user_blp)
    api.register_blueprint(meta_blp)
    api.register_blueprint(lis_blp)
    api.register_blueprint(sta_blp)
    api.register_blueprint(modu_blp)
    api.register_blueprint(agen_blp)

    conn = database_connect()

    main = empireMenu

    global serverExitCommand

    # if a username/password were not supplied, use the creds stored in the db
    # (dbUsername, dbPassword) = execute_db_query(conn, "SELECT api_username, api_password FROM config")[0]

    if username:
        Users.update_username(1, username[0])

    if password:
        Users.update_password(1, password[0])

    print('')
    print(" * Starting Empire RESTful API on port: %s" % (port))

    oldStdout = sys.stdout
    if suppress:
        # suppress the normal Flask output
        log = logging.getLogger('werkzeug')
        log.setLevel(logging.ERROR)

        # suppress all stdout and don't initiate the main cmdloop
        sys.stdout = open(os.devnull, 'w')

    # validate API token before every request except for the login URI
    @app.before_request
    def check_token():
        """
        Before every request, check if a valid token is passed along with the request.
        """
        try:
            if request.path != '/api/users/login' and not request.path.startswith('/doc'):
                token = request.args.get('token')
                user = Users.get_user_from_token(token)
                if user:
                    g.user = user
                    # I don't love this, but its a way to get access to the correct instances from the blueprints.
                    # Ideally, I think I'd like to be able to have single instances of the listener, agents, etc
                    # that can be imported anywhere and not worry about it being attached to the main object.
                    # But that might just be the Java programmer in me?
                    g.main = main
                else:
                    return make_response('', 401)
        except:
            return make_response('', 401)

    @app.after_request
    def add_cors(response):
        response.headers['Access-Control-Allow-Origin'] = '*'
        return response

    @app.teardown_request
    def remove_session(ex):
        Session().commit()
        Session.remove()

    @app.errorhandler(Exception)
    def exception_handler(error):
        """
        Generic exception handler.
        """
        code = error.code if hasattr(error, 'code') else '500'
        return make_response(jsonify({'error': repr(error)}), code)

    @app.route('/api/creds', methods=['GET'])
    def get_creds():
        """
        Returns JSON describing the credentials stored in the backend database.
        """
        credsRaw = execute_db_query(conn,
                                    'SELECT ID, credtype, domain, username, password, host, os, sid, notes FROM credentials')
        creds = []

        for credRaw in credsRaw:
            [ID, credtype, domain, username, password, host, os, sid, notes] = credRaw
            creds.append({"ID": ID, "credtype": credtype, "domain": domain, "username": username, "password": password,
                          "host": host, "os": os, "sid": sid, "notes": notes})

        return jsonify({'creds': creds})

    @app.route('/api/creds', methods=['POST'])
    def add_creds():
        """
        Adds credentials to the database
        """
        if not request.json:
            return make_response(jsonify({'error': 'request body must be valid JSON'}), 400)

        if not 'credentials' in request.json:
            return make_response(jsonify({'error': 'JSON body must include key "credentials"'}), 400)

        creds = request.json['credentials']

        if not type(creds) == list:
            return make_response(jsonify({'error': 'credentials must be provided as a list'}), 400)

        required_fields = ["credtype", "domain", "username", "password", "host"]
        optional_fields = ["OS", "notes", "sid"]

        for cred in creds:
            # ensure every credential given to us has all the required fields
            if not all(k in cred for k in required_fields):
                return make_response(jsonify({'error': 'invalid credential %s' % (cred)}), 400)

            # ensure the type is either "hash" or "plaintext"
            if not (cred['credtype'] == u'hash' or cred['credtype'] == u'plaintext'):
                return make_response(
                    jsonify({'error': 'invalid credential type in %s, must be "hash" or "plaintext"' % (cred)}), 400)

        # other than that... just assume everything is valid

        # this would be way faster if batched but will work for now
        for cred in creds:
            # get the optional stuff, if it's there
            try:
                os = cred['os']
            except KeyError:
                os = ''

            try:
                sid = cred['sid']
            except KeyError:
                sid = ''

            try:
                notes = cred['notes']
            except KeyError:
                notes = ''

            main.credentials.add_credential(
                cred['credtype'],
                cred['domain'],
                cred['username'],
                cred['password'],
                cred['host'],
                os,
                sid,
                notes
            )

        return jsonify({'success': '%s credentials added' % len(creds)})

    @app.route('/api/reporting', methods=['GET'])
    def get_reporting():
        """
        Returns JSON describing the reporting events from the backend database.
        """
        reportingRaw = execute_db_query(conn, 'SELECT ID, name, event_type, message, time_stamp, taskID FROM reporting')
        reportingEvents = []

        for reportingEvent in reportingRaw:
            [ID, name, event_type, message, time_stamp, taskID] = reportingEvent
            reportingEvents.append(
                {"ID": ID, "agentname": name, "event_type": event_type, "message": json.loads(message),
                 "timestamp": time_stamp, "taskID": taskID})

        return jsonify({'reporting': reportingEvents})

    @app.route('/api/reporting/agent/<string:reporting_agent>', methods=['GET'])
    def get_reporting_agent(reporting_agent):
        """
        Returns JSON describing the reporting events from the backend database for
        the agent specified by reporting_agent.
        """

        # first resolve the supplied name to a sessionID
        results = execute_db_query(conn, 'SELECT session_id FROM agents WHERE name=?', [reporting_agent])
        if results:
            sessionID = results[0][0]
        else:
            return jsonify({'reporting': ''})

        reportingRaw = execute_db_query(conn,
                                        'SELECT ID, name, event_type, message, time_stamp, taskID FROM reporting WHERE name=?',
                                        [sessionID])
        reportingEvents = []

        for reportingEvent in reportingRaw:
            [ID, name, event_type, message, time_stamp, taskID] = reportingEvent
            reportingEvents.append(
                {"ID": ID, "agentname": name, "event_type": event_type, "message": json.loads(message),
                 "timestamp": time_stamp, "taskID": taskID})

        return jsonify({'reporting': reportingEvents})

    @app.route('/api/reporting/type/<string:event_type>', methods=['GET'])
    def get_reporting_type(event_type):
        """
        Returns JSON describing the reporting events from the backend database for
        the event type specified by event_type.
        """
        reportingRaw = execute_db_query(conn,
                                        'SELECT ID, name, event_type, message, time_stamp, taskID FROM reporting WHERE event_type=?',
                                        [event_type])
        reportingEvents = []

        for reportingEvent in reportingRaw:
            [ID, name, event_type, message, time_stamp, taskID] = reportingEvent
            reportingEvents.append(
                {"ID": ID, "agentname": name, "event_type": event_type, "message": json.loads(message),
                 "timestamp": time_stamp, "taskID": taskID})

        return jsonify({'reporting': reportingEvents})

    @app.route('/api/reporting/msg/<string:msg>', methods=['GET'])
    def get_reporting_msg(msg):
        """
        Returns JSON describing the reporting events from the backend database for
        the any messages with *msg* specified by msg.
        """
        reportingRaw = execute_db_query(conn,
                                        "SELECT ID, name, event_type, message, time_stamp, taskID FROM reporting WHERE message like ?",
                                        ['%' + msg + '%'])
        reportingEvents = []

        for reportingEvent in reportingRaw:
            [ID, name, event_type, message, time_stamp, taskID] = reportingEvent
            reportingEvents.append(
                {"ID": ID, "agentname": name, "event_type": event_type, "message": json.loads(message),
                 "timestamp": time_stamp, "taskID": taskID})

        return jsonify({'reporting': reportingEvents})

    @app.route('/api/admin/restart', methods=['GET', 'POST', 'PUT'])
    def signal_server_restart():
        """
        Signal a restart for the Flask server and any Empire instance.
        """
        restart_server()
        return jsonify({'success': True})

    @app.route('/api/admin/shutdown', methods=['GET', 'POST', 'PUT'])
    def signal_server_shutdown():
        """
        Signal a restart for the Flask server and any Empire instance.
        """
        shutdown_server()
        return jsonify({'success': True})

    if not os.path.exists('./data/empire-chain.pem'):
        print("[!] Error: cannot find certificate ./data/empire-chain.pem")
        sys.exit()

    def shutdown_server():
        """
        Shut down the Flask server and any Empire instance gracefully.
        """
        global serverExitCommand

        if suppress:
            # repair stdout
            sys.stdout.close()
            sys.stdout = oldStdout

        print("\n * Shutting down Empire RESTful API")

        if conn:
            conn.close()

        if suppress:
            print(" * Shutting down the Empire instance")
            main.shutdown()

        serverExitCommand = 'shutdown'

        func = request.environ.get('werkzeug.server.shutdown')
        if func is not None:
            func()

    def restart_server():
        """
        Restart the Flask server and any Empire instance.
        """
        global serverExitCommand

        shutdown_server()

        serverExitCommand = 'restart'

    def signal_handler(signal, frame):
        """
        Overrides the keyboardinterrupt signal handler so we can gracefully shut everything down.
        """

        global serverExitCommand

        with app.test_request_context():
            shutdown_server()

        serverExitCommand = 'shutdown'

        # repair the original signal handler
        import signal
        signal.signal(signal.SIGINT, signal.default_int_handler)
        sys.exit()

    try:
        signal.signal(signal.SIGINT, signal_handler)
    except ValueError:
        pass

    # wrap the Flask connection in SSL and start it
    certPath = os.path.abspath("./data/")

    # support any version of tls
    pyversion = sys.version_info
    if pyversion[0] == 2 and pyversion[1] == 7 and pyversion[2] >= 13:
        proto = ssl.PROTOCOL_TLS
    elif pyversion[0] >= 3:
        proto = ssl.PROTOCOL_TLS
    else:
        proto = ssl.PROTOCOL_SSLv23

    context = ssl.SSLContext(proto)
    context.load_cert_chain("%s/empire-chain.pem" % (certPath), "%s/empire-priv.key" % (certPath))

    if insecure:
        app.run(host='0.0.0.0', port=int(port), threaded=True)
    else:
        app.run(host='0.0.0.0', port=int(port), ssl_context=context, threaded=True)

if __name__ == '__main__':

    parser = argparse.ArgumentParser()

    generalGroup = parser.add_argument_group('General Options')
    generalGroup.add_argument('--debug', nargs='?', const='1',
                              help='Debug level for output (default of 1, 2 for msg display).')
    generalGroup.add_argument('-v', '--version', action='store_true', help='Display current Empire version.')
    generalGroup.add_argument('-r', '--resource', nargs=1,
                              help='Run the Empire commands in the specified resource file after startup.')

    cliGroup = parser.add_argument_group('CLI Payload Options')
    cliGroup.add_argument('-l', '--listener', nargs='?', const="list",
                          help='Display listener options. Displays all listeners if nothing is specified.')
    cliGroup.add_argument('-s', '--stager', nargs='?', const="list",
                          help='Specify a stager to generate. Lists all stagers if none is specified.')
    cliGroup.add_argument('-o', '--stager-options', nargs='*',
                          help="Supply options to set for a stager in OPTION=VALUE format. Lists options if nothing is specified.")

    restGroup = parser.add_argument_group('RESTful API Options')
    launchGroup = restGroup.add_mutually_exclusive_group()
    launchGroup.add_argument('--rest', action='store_true', help='Run Empire and the RESTful API.')
    launchGroup.add_argument('--headless', action='store_true',
                             help='Run Empire and the RESTful API headless without the usual interface.')
    restGroup.add_argument('--restport', type=int, nargs=1, help='Port to run the Empire RESTful API on.')
    restGroup.add_argument('--username', nargs=1,
                           help='Start the RESTful API with the specified username instead of pulling from empire.db')
    restGroup.add_argument('--password', nargs=1,
                           help='Start the RESTful API with the specified password instead of pulling from empire.db')
    restGroup.add_argument('--insecure', action="store_true", help="Run Empire's Api without ssl")

    args = parser.parse_args()
    database_check_docker()

    if not args.restport:
        args.restport = '1337'
    else:
        args.restport = args.restport[0]

    if args.version:
        print(empire.VERSION)

    elif args.rest:
        # start an Empire instance and RESTful API
        main = empire.MainMenu(args=args)


        def thread_api(empireMenu):

            try:
                start_restful_api(empireMenu=empireMenu, suppress=False, username=args.username, password=args.password,
                                  port=args.restport, insecure=args.insecure)
            except SystemExit as e:
                pass


        thread = helpers.KThread(target=thread_api, args=(main,))
        thread.daemon = True
        thread.start()
        sleep(2)
        main.cmdloop()

    elif args.headless:
        # start an Empire instance and RESTful API and suppress output
        main = empire.MainMenu(args=args)
        try:
            start_restful_api(empireMenu=main, suppress=True, username=args.username, password=args.password,
                              port=args.restport)
        except SystemExit as e:
            pass

    else:
        # normal execution
        main = empire.MainMenu(args=args)
        main.cmdloop()

    sys.exit()
